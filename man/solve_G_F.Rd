% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimate_CG.R
\name{solve_G_F}
\alias{solve_G_F}
\title{Iterative scheme for calculation of Copula-Graphic Estimator}
\usage{
solve_G_F(
  F_t_i_minus_1,
  G_t_i_minus_1,
  mu_C_B_t_i_minus_1,
  copula,
  error_A = 1e-07,
  error_B = 1e-05,
  i,
  p_1,
  k,
  theta = NA,
  tau = NA
)
}
\arguments{
\item{F_t_i_minus_1}{The estimate for \eqn{F(t[i-1])}. This input
parameter is given by the previous iteration step.}

\item{G_t_i_minus_1}{The estimate for \eqn{G(t[i-1])}. This input
parameter is given by the previous iteration step.}

\item{mu_C_B_t_i_minus_1}{The estimate for \eqn{mu_C(B_t[i-1]))}.
This input parameter is given by the previous iteration step.}

\item{copula}{Copula function to be applied for the Copula-Graphic Estimator.}

\item{error_A}{Error tolerance for the first iteration step. The estimate for
\eqn{G(t[i])} is accepted if \eqn{|mu_C(A(t[i])) -k(t[i])| <} \code{error_A}.}

\item{error_B}{Error tolerance for the second iteration step. The estimated
pair \eqn{(F(t[i]), G(t[i]))} is accepted if
\eqn{|mu_C(B_t[i])) - p_1(t[i])| <} \code{error_B}.}

\item{i}{Iteration parameter.}

\item{p_1}{Empirical estimate est \eqn{p_1(t[i])} for \eqn{P(X \le t[i], \delta = 1)}.
See documentation of function \link[copulagraphicr]{estimate_quantities}.}

\item{k}{Empirical estimate est \eqn{k(t[i])} for \eqn{P(X > t[i], Y > t[i])}.
See documentaion of function \link[copulagraphicr]{estimate_quantities}.}

\item{theta}{Parameter of the following copulas:
\itemize{
\item Gamma Frailty Copula, \code{theta} \eqn{\ge 1}
\item Gumbel Copula, \code{theta} \eqn{\ge 1}
\item Frank Copula, \code{theta} \eqn{=/= 0}
\item Clayton Copula, \code{theta} \eqn{\ge -1}
\item Joe's Copula, \code{theta} \eqn{\ge 1}
}
If set to \code{NA}, \code{theta} is chosen such that
Kendall's \eqn{\tau = 0.5}. Note that the parameter \code{theta} is only used, if \code{NA} value for
\code{tau} is passed.}

\item{tau}{Kendall's \eqn{\tau}.}
}
\description{
Two step iterative bisection scheme to solve the following system of non-linear equations:
\itemize{
\item (1) \eqn{mu_C(A_t[i]) = k(t[i]),}
\item (2) \eqn{mu_C(B_t[i]) =  p_1(t[i]).}
}
Notation:
\itemize{
\item \eqn{A_t[i] = { (x,y) : F(t[i]) \le x \le 1, G(t[i]) \le y \le 1 } }
\item \eqn{B_t[i] = { (x,y) : 0 \le F(t[i]) \le 1, GF^{-1}(t[i]) \le y \le 1 } }
\item \eqn{k(t[i]) = 1/n \sum_k 1_(X_k > t[i], Y_k > t[i])}
\item \eqn{p_1(t[i]) = 1/n \sum_k 1_(X_k \le t[i], \delta_k = 1)}
}

It can be shown that
\itemize{
\item \eqn{ mu_C(A_t[i]) = 1 - G(t[i]) - F(t[i]) + C(F(t[i]), G(t[i]))} and
\item \eqn{mu_C(B_t[i]) = mu_C(B_t[i-1]) + F(t[i]) - F(t[i-1]) + C(F(t[i-1]), G(t[i])) - C(F(t[i]), G(t[i]))}.
}
Note: in the i-th iteration step, the variables \eqn{F(t[i-1])} and \eqn{mu_C(B_t[i-1])} are known input parameters.
Hence, there exists a unique solution, since there are two equations and two unknown variables.

In the first step a candidate \eqn{F_t_i} for \eqn{F(t[i])} is proposed. Then the
first equation is solved for the corresponding candidate \eqn{G_t_i} for \eqn{G(t[i])}.
The equation is solved using a bisection algorithm and the candidate \eqn{G_t_i} is accepted, if
the error \eqn{|mu_C(A_t[i]) - k(t[i])|} is smaller than \code{error_A}. Note that for a bad initial choice of
\eqn{F_t_i}, it may happen that there is no solution. In this case, the algorithm stops after \eqn{iter_max_A}
steps and a new candidate \eqn{F_t_i} is selected.

In the second step the pair \eqn{(F_t_i, G_t_i)} is proposed as a solution for
the second equation. If \eqn{|mu_C(B_t[i]) - p_1(t[i])|} is smaller than \code{error_B}, the pair is accepted
as a solution. Else a new candidate for \eqn{F_t_i} is selected.
}
\examples{
\donttest{## load data set:
# sample_data <- copulagraphicr::load_data()

## estimate empirical quantities:
# est <- copulagraphicr::estimate_quantities(sample_data = sample_data)
# t_grid <- est[[1]]
# k <- est[[2]]
# p_1 <- est[[3]]
# p_2 <- est[[4]]
}

# F_hat <- c(0)
# G_hat <- c(0)
# mu_C_B <- c(0)
# mu_C_A <- c(0)
#
# solve <- copulagraphicr::solve_G_F(F_t_i_minus_1 = F_hat[i-1],
#                      G_t_i_minus_1 = G_hat[i-1],
#                      mu_C_B_t_i_minus_1 = mu_C_B[i-1],
#                      copula = copulagraphicr::C_independence,
#                      i = 2,
#                      p_1 = p_1,
#                      k = k)
# F_hat[i] <- solve[[1]]
# G_hat[i] <- solve[[2]]
# mu_C_B[i] <- solve[[3]]
# mu_C_A[i] <- solve[[4]]
}
